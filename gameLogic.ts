// =====================================================================================
//                             تولید اعداد تصادفی امن
// =====================================================================================

/**
 * یک عدد صحیح تصادفی در بازه مشخص شده (شامل خود اعداد) تولید می‌کند.
 * 
 * @param min - حداقل عدد ممکن (شامل خود عدد).
 * @param max - حداکثر عدد ممکن (شامل خود عدد).
 * @returns یک عدد صحیح تصادفی بین min و max.
 * 
 * چرا از window.crypto.getRandomValues استفاده شده است؟
 * این متد نسبت به Math.random() از نظر رمزنگاری امن‌تر و توزیع تصادفی بهتری دارد.
 * برای بازی‌هایی که نیاز به تصادفی بودن واقعی دارند (مانند بازی تاس)، استفاده از این API
 * انتخاب بهتری است تا از الگوهای قابل پیش‌بینی جلوگیری شود.
 */
export const getRandomInt = (min: number, max: number): number => {
  // 1. یک آرایه 32 بیتی بدون علامت برای نگهداری عدد تصادفی ایجاد می‌کنیم.
  const randomBuffer = new Uint32Array(1);
  
  // 2. این بافر را با یک عدد تصادفی امن پر می‌کنیم.
  window.crypto.getRandomValues(randomBuffer);
  
  // 3. عدد 32 بیتی را به یک عدد اعشاری بین 0 (شامل) و 1 (خارج) تبدیل می‌کنیم.
  //    این کار با تقسیم عدد تصادفی بر بزرگترین مقدار ممکن (2^32 - 1) به علاوه یک انجام می‌شود.
  const randomNumber = randomBuffer[0] / (0xffffffff + 1);
  
  // 4. برای اطمینان از اینکه بازه شامل اعداد صحیح است، min و max را گرد می‌کنیم.
  min = Math.ceil(min);
  max = Math.floor(max);
  
  // 5. عدد اعشاری نرمال شده را به بازه دلخواه (max - min + 1) مقیاس می‌دهیم،
  //    آن را به پایین گرد کرده و با min جمع می‌کنیم تا عدد نهایی در بازه مورد نظر قرار گیرد.
  return Math.floor(randomNumber * (max - min + 1)) + min;
};


// =====================================================================================
//                             محاسبه امتیاز و جایزه
// =====================================================================================

/**
 * امتیاز پایه، جایزه و پیام مربوط به جایزه را بر اساس مقادیر تاس‌ها محاسبه می‌کند.
 * @param diceValues - آرایه‌ای از اعداد که مقادیر تاس‌های پرتاب شده را نشان می‌دهد.
 * @returns یک آبجکت شامل:
 *   - baseScore: مجموع ساده مقادیر تاس‌ها.
 *   - bonus: امتیاز جایزه‌ای که بر اساس قوانین خاص (جفت، سه‌تایی و غیره) محاسبه می‌شود.
 *   - bonusMessage: یک رشته متنی که نحوه محاسبه جایزه را توضیح می‌دهد.
 */
export const calculateScoreAndBonus = (diceValues: number[]) => {
    // امتیاز پایه، مجموع تمام اعداد روی تاس‌هاست.
    // از متد reduce برای جمع کردن سریع تمام مقادیر آرایه استفاده می‌کنیم.
    let baseScore = diceValues.reduce((a, b) => a + b, 0);
    
    // متغیر bonus برای نگهداری امتیازات جایزه.
    let bonus = 0;
    
    // آرایه‌ای برای نگهداری پیام‌های مربوط به هر جایزه.
    const bonusMessages: string[] = [];
    
    // اگر هیچ تاسی وجود نداشته باشد، محاسبات را متوقف کرده و صفر برمی‌گردانیم.
    if (diceValues.length < 1) {
        return { baseScore, bonus, bonusMessage: '' };
    }

    // --- شمارش تکرار هر عدد ---
    // برای محاسبه جایزه، ابتدا باید بدانیم هر عدد چند بار تکرار شده است.
    // از reduce برای ایجاد یک "نقشه فراوانی" (frequency map) استفاده می‌کنیم.
    // خروجی این بخش یک آبجکت است که کلیدهای آن مقادیر تاس (مثلاً 1 تا 6)
    // و مقادیر آن تعداد تکرار هر عدد است.
    // مثال: برای تاس‌های [2, 5, 2, 6, 2]، آبجکت counts برابر خواهد بود با: { '2': 3, '5': 1, '6': 1 }
    const counts: { [key: number]: number } = diceValues.reduce((acc, val) => {
        acc[val] = (acc[val] || 0) + 1;
        return acc;
    }, {} as { [key: number]: number });

    // --- بررسی قوانین جایزه ---

    // قانون جدید: اگر "دقیقا یک" تاس 6 آمده باشد، 1 امتیاز جایزه اضافه می‌شود.
    // این قانون در صورتی که دو یا چند تاس 6 بیاید، اعمال نمی‌شود.
    if (counts[6] === 1) {
        bonus += 1;
        bonusMessages.push('تاس ۶: ۱+');
    }


    // حلقه for...in برای پیمایش روی کلیدهای آبجکت counts (یعنی مقادیر منحصر به فرد تاس‌ها).
    for (const numStr in counts) {
        // کلیدهای آبجکت رشته هستند، پس ابتدا آن را به عدد تبدیل می‌کنیم.
        const num = parseInt(numStr, 10);
        const count = counts[num];
        
        let matchBonus = 0;
        let matchMessage = '';

        // بررسی قوانین مربوط به تاس‌های مشابه (جفت، سه‌تایی و غیره)
        if (count === 2) { // اگر جفت بود
            matchBonus = num; // جایزه برابر با خود عدد است.
            matchMessage = `جفت ${num}: ${matchBonus}+`;
        } else if (count === 3) { // اگر سه‌تایی بود
            matchBonus = num * 2; // جایزه دو برابر خود عدد است.
            matchMessage = `سه تایی ${num}: ${matchBonus}+`;
        } else if (count === 4) { // اگر چهارتایی بود
            matchBonus = num * 3; // جایزه سه برابر خود عدد است.
            matchMessage = `چهارتایی ${num}: ${matchBonus}+`;
        } else if (count === 5) { // اگر پنج‌تایی بود
            matchBonus = num * 4; // جایزه چهار برابر خود عدد است.
            matchMessage = `پنج تایی ${num}: ${matchBonus}+`;
        }
        
        // اگر جایزه‌ای در این حلقه محاسبه شد، آن را به مجموع جوایز و پیام‌ها اضافه می‌کنیم.
        if (matchBonus > 0) {
            bonus += matchBonus;
            bonusMessages.push(matchMessage);
        }
    }

    // در نهایت، آبجکت نتیجه را با پیام‌های ترکیب شده برمی‌گردانیم.
    // متد join(' | ') پیام‌ها را با یک جداکننده زیبا به هم متصل می‌کند.
    return { baseScore, bonus, bonusMessage: bonusMessages.join(' | ') };
};
